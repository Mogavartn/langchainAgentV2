import os
import logging
from typing import Dict, Any, Optional, List
from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
import json
import re
from dataclasses import dataclass
import traceback

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(levelname)s:%(name)s:%(message)s'
)
logger = logging.getLogger(__name__)

app = FastAPI(title="JAK Company RAG Robust API", version="2.1")

# Configuration CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# VÃ©rification de la clÃ© API OpenAI
openai_key = os.getenv("OPENAI_API_KEY")
if openai_key:
    os.environ["OPENAI_API_KEY"] = openai_key
    logger.info("OpenAI API Key configured")
else:
    logger.warning("OpenAI API Key not found - some features may not work")

# Store pour la mÃ©moire des conversations (simplifiÃ©)
memory_store: Dict[str, List] = {}

@dataclass
class SimpleRAGDecision:
    """Structure simplifiÃ©e pour les dÃ©cisions RAG"""
    search_query: str
    search_strategy: str
    context_needed: List[str]
    priority_level: str
    should_escalate: bool
    system_instructions: str

class SimpleRAGEngine:
    """Moteur de dÃ©cision RAG ultra-simplifiÃ© et robuste"""
    
    @staticmethod
    def analyze_intent(message: str, session_id: str = "default") -> SimpleRAGDecision:
        """Analyse l'intention de maniÃ¨re robuste"""
        
        try:
            logger.info(f"ðŸ§  ANALYSE INTENTION: '{message[:50]}...'")
            
            message_lower = message.lower().strip()
            
            # === NOUVEAUX BLOCS : DÃ‰FINITIONS AMBASSADEUR/AFFILIATION ===
            definition_keywords = [
                "c'est quoi", "qu'est-ce que", "dÃ©finition", "qu'est ce que",
                "c'est quoi un ambassadeur", "dÃ©finir", "expliquer"
            ]
            
            if any(keyword in message_lower for keyword in definition_keywords):
                if "ambassadeur" in message_lower:
                    logger.info("ðŸŽ¯ DÃ‰FINITION AMBASSADEUR DÃ‰TECTÃ‰E")
                    return SimpleRAGDecision(
                        search_query="dÃ©finition ambassadeur partenaire argent commission",
                        search_strategy="semantic",
                        context_needed=["ambassadeur", "definition", "explication"],
                        priority_level="medium",
                        should_escalate=False,
                        system_instructions="""CONTEXTE DÃ‰TECTÃ‰: DÃ‰FINITION AMBASSADEUR

Tu dois OBLIGATOIREMENT:
1. Chercher le bloc AMBASSADEUR_DEFINITION dans Supabase
2. Reproduire EXACTEMENT le bloc avec tous les emojis
3. Ne pas improviser ou rÃ©sumer
4. Proposer ensuite d'approfondir avec "devenir ambassadeur"
5. Maintenir le ton chaleureux JAK Company"""
                    )
                elif "affiliation" in message_lower and ("mail" in message_lower or "reÃ§u" in message_lower):
                    logger.info("ðŸŽ¯ DÃ‰FINITION AFFILIATION DÃ‰TECTÃ‰E")
                    return SimpleRAGDecision(
                        search_query="affiliation programme mail dÃ©finition",
                        search_strategy="semantic", 
                        context_needed=["affiliation", "definition", "programme"],
                        priority_level="medium",
                        should_escalate=False,
                        system_instructions="""CONTEXTE DÃ‰TECTÃ‰: DÃ‰FINITION AFFILIATION

Tu dois OBLIGATOIREMENT:
1. Chercher le bloc AFFILIATION_DEFINITION dans Supabase
2. Reproduire EXACTEMENT le bloc avec tous les emojis
3. Poser la question de clarification (formation terminÃ©e vs ambassadeur)
4. Ne pas combiner avec d'autres blocs
5. Maintenir le ton WhatsApp chaleureux"""
                    )
            
            # === DÃ‰TECTION PAIEMENT (PRIORITÃ‰ HAUTE) ===
            payment_keywords = [
                "pas Ã©tÃ© payÃ©", "pas payÃ©", "paiement", "cpf", "opco", 
                "virement", "argent", "retard", "dÃ©lai", "attends",
                "finance", "financement", "payÃ© pour", "rien reÃ§u",
                "je vais Ãªtre payÃ© quand", "dÃ©lai paiement"
            ]
            
            if any(keyword in message_lower for keyword in payment_keywords):
                logger.info("ðŸŽ¯ CONTEXTE PAIEMENT DÃ‰TECTÃ‰")
                return SimpleRAGDecision(
                    search_query=f"paiement formation dÃ©lai cpf opco {message}",
                    search_strategy="hybrid",
                    context_needed=["paiement", "cpf", "opco", "financement", "dÃ©lai"],
                    priority_level="high",
                    should_escalate=True,
                    system_instructions="""CONTEXTE DÃ‰TECTÃ‰: PAIEMENT FORMATION

RÃˆGLE ABSOLUE - FILTRAGE PAIEMENT OBLIGATOIRE:
1. Chercher d'abord dans Supabase les blocs paiement (Bloc F, F1, F2, F3)
2. OBLIGATOIRE: Poser les questions de filtrage:
   - Comment la formation a Ã©tÃ© financÃ©e ? (CPF, OPCO, direct)
   - Environ quand elle s'est terminÃ©e ?
3. Appliquer les dÃ©lais de rÃ©fÃ©rence:
   - Direct: â‰¤7j normal, >7j ESCALADE
   - CPF: â‰¤45j normal, >45j vÃ©rifier CPF BLOQUÃ‰
   - OPCO: â‰¤2 mois normal, >2 mois ESCALADE
4. Si CPF bloquÃ© dÃ©tectÃ© â†’ Bloc F1 ou F2
5. Si dÃ©lai OPCO dÃ©passÃ© â†’ Bloc F3 + ESCALADE ADMIN
6. Reproduire les blocs EXACTEMENT avec tous les emojis
7. NE JAMAIS escalader sans avoir les infos financement + date"""
                )
            
            # === DÃ‰TECTION AMBASSADEUR ===
            ambassador_keywords = [
                "ambassadeur", "commission", "affiliation", "partenaire",
                "gagner argent", "contacts", "Ã©tapes", "devenir",
                "programme", "recommander", "comment je deviens",
                "comment devenir ambassadeur"
            ]
            
            if any(keyword in message_lower for keyword in ambassador_keywords):
                # Ã‰viter les conflits avec les dÃ©finitions
                if not any(def_kw in message_lower for def_kw in definition_keywords):
                    logger.info("ðŸŽ¯ CONTEXTE AMBASSADEUR DÃ‰TECTÃ‰")
                    return SimpleRAGDecision(
                        search_query=f"ambassadeur programme affiliation Ã©tapes {message}",
                        search_strategy="semantic",
                        context_needed=["ambassadeur", "commission", "Ã©tapes", "affiliation", "programme"],
                        priority_level="high",
                        should_escalate=False,
                        system_instructions="""CONTEXTE DÃ‰TECTÃ‰: AMBASSADEUR

Tu dois OBLIGATOIREMENT:
1. Identifier le type de demande ambassadeur:
   - DÃ©couverte programme â†’ Bloc B
   - Devenir ambassadeur â†’ Bloc D  
   - Envoi contacts â†’ Bloc E
   - Suivi paiement â†’ Appliquer FILTRAGE PAIEMENT
2. Chercher le bloc appropriÃ© dans Supabase
3. Reproduire EXACTEMENT avec tous les emojis et liens
4. Si demande "4 Ã©tapes" â†’ donner les Ã©tapes complÃ¨tes du Bloc D
5. Ne jamais combiner plusieurs blocs
6. Maintenir le ton WhatsApp avec emojis naturels"""
                    )
            
            # === DÃ‰TECTION ENVOI CONTACTS ===
            contact_keywords = [
                "comment envoyer", "envoie des contacts", "transmettre contacts",
                "formulaire", "liste contacts", "comment je vous envoie"
            ]
            
            if any(keyword in message_lower for keyword in contact_keywords):
                logger.info("ðŸŽ¯ CONTEXTE ENVOI CONTACTS DÃ‰TECTÃ‰")
                return SimpleRAGDecision(
                    search_query="envoyer contacts formulaire nom prÃ©nom tÃ©lÃ©phone",
                    search_strategy="semantic",
                    context_needed=["contacts", "formulaire", "transmission"],
                    priority_level="medium",
                    should_escalate=False,
                    system_instructions="""CONTEXTE DÃ‰TECTÃ‰: ENVOI CONTACTS

Tu dois OBLIGATOIREMENT:
1. Chercher le Bloc E dans Supabase
2. Reproduire EXACTEMENT avec le lien formulaire
3. Mentionner: nom, prÃ©nom, contact (tel/email)
4. Bonus SIRET pour les pros
5. Maintenir le ton encourageant et simple"""
                )
            
            # === DÃ‰TECTION FORMATION ===
            formation_keywords = [
                "formation", "cours", "apprendre", "catalogue", "proposez",
                "disponible", "enseigner", "stage", "bureautique", 
                "informatique", "langues", "anglais", "excel"
            ]
            
            if any(keyword in message_lower for keyword in formation_keywords):
                logger.info("ðŸŽ¯ CONTEXTE FORMATION DÃ‰TECTÃ‰")
                return SimpleRAGDecision(
                    search_query=f"formation catalogue cpf opco {message}",
                    search_strategy="semantic",
                    context_needed=["formation", "cpf", "catalogue", "professionnel"],
                    priority_level="medium",
                    should_escalate=False,
                    system_instructions="""CONTEXTE DÃ‰TECTÃ‰: FORMATION

Tu dois OBLIGATOIREMENT:
1. Si question CPF â†’ Bloc C (plus de CPF disponible)
2. Chercher les informations formations dans Supabase
3. Identifier le profil (pro, particulier, entreprise)
4. Orienter vers les bons financements (OPCO, entreprise)
5. Proposer contact humain si besoin (Bloc G)"""
                )
            
            # === DÃ‰TECTION PARLER Ã€ UN HUMAIN ===
            human_keywords = [
                "parler humain", "contact humain", "Ã©quipe", "quelqu'un",
                "agent", "conseiller", "je veux parler"
            ]
            
            if any(keyword in message_lower for keyword in human_keywords):
                logger.info("ðŸŽ¯ CONTEXTE CONTACT HUMAIN DÃ‰TECTÃ‰")
                return SimpleRAGDecision(
                    search_query="parler humain contact Ã©quipe",
                    search_strategy="semantic",
                    context_needed=["humain", "contact", "escalade"],
                    priority_level="medium",
                    should_escalate=True,
                    system_instructions="""CONTEXTE DÃ‰TECTÃ‰: CONTACT HUMAIN

Tu dois OBLIGATOIREMENT:
1. Chercher le Bloc G dans Supabase
2. Reproduire EXACTEMENT avec les horaires
3. Proposer d'abord de rÃ©pondre directement
4. Mentionner les horaires: 9h-17h, lun-ven
5. Escalader si vraiment nÃ©cessaire"""
                )
            
            # === DÃ‰TECTION CPF ===
            cpf_keywords = [
                "cpf", "compte personnel", "vous faites encore le cpf",
                "formations cpf", "financement cpf"
            ]
            
            if any(keyword in message_lower for keyword in cpf_keywords):
                logger.info("ðŸŽ¯ CONTEXTE CPF DÃ‰TECTÃ‰")
                return SimpleRAGDecision(
                    search_query="cpf formation financement opco",
                    search_strategy="semantic",
                    context_needed=["cpf", "financement", "alternatives"],
                    priority_level="medium",
                    should_escalade=False,
                    system_instructions="""CONTEXTE DÃ‰TECTÃ‰: CPF

Tu dois OBLIGATOIREMENT:
1. Chercher le Bloc C dans Supabase
2. Reproduire EXACTEMENT: plus de CPF pour le moment
3. Proposer alternatives pour pros (OPCO, entreprise)
4. Donner les liens rÃ©seaux sociaux pour Ãªtre tenu au courant
5. Proposer d'expliquer pour les pros"""
                )
            
            # === DÃ‰TECTION ARGUMENTAIRE/PROSPECT ===
            prospect_keywords = [
                "que dire Ã  un prospect", "argumentaire", "comment prÃ©senter",
                "offres", "comprendre", "expliquer Ã  quelqu'un"
            ]
            
            if any(keyword in message_lower for keyword in prospect_keywords):
                logger.info("ðŸŽ¯ CONTEXTE PROSPECT/ARGUMENTAIRE DÃ‰TECTÃ‰")
                return SimpleRAGDecision(
                    search_query="argumentaire prospect entreprise formation",
                    search_strategy="semantic",
                    context_needed=["prospect", "argumentaire", "prÃ©sentation"],
                    priority_level="medium",
                    should_escalade=False,
                    system_instructions="""CONTEXTE DÃ‰TECTÃ‰: ARGUMENTAIRE PROSPECT

Tu dois OBLIGATOIREMENT:
1. Identifier le type d'argumentaire:
   - Que dire Ã  un prospect â†’ Bloc H
   - Argumentaire entreprise â†’ Bloc I1  
   - Argumentaire ambassadeur â†’ Bloc I2
2. Reproduire le bloc appropriÃ© EXACTEMENT
3. Maintenir le ton professionnel mais accessible"""
                )
            
            # === DÃ‰TECTION COMBIEN DE TEMPS ===
            time_keywords = [
                "combien de temps", "dÃ©lai", "Ã§a prend combien", "durÃ©e",
                "quand", "temps nÃ©cessaire"
            ]
            
            if any(keyword in message_lower for keyword in time_keywords):
                logger.info("ðŸŽ¯ CONTEXTE DÃ‰LAI/TEMPS DÃ‰TECTÃ‰")
                return SimpleRAGDecision(
                    search_query="dÃ©lai temps paiement formation mois",
                    search_strategy="semantic",
                    context_needed=["dÃ©lai", "temps", "durÃ©e"],
                    priority_level="medium",
                    should_escalade=False,
                    system_instructions="""CONTEXTE DÃ‰TECTÃ‰: DÃ‰LAI/TEMPS

Tu dois OBLIGATOIREMENT:
1. Chercher le Bloc J dans Supabase
2. Reproduire EXACTEMENT: 3-6 mois en moyenne
3. Expliquer les facteurs (financement, rÃ©activitÃ©, traitement)
4. Donner les exemples de dÃ©lais par type
5. Conseiller d'envoyer plusieurs contacts au dÃ©but"""
                )
            
            # === DÃ‰TECTION MOTS ILLÃ‰GAUX ===
            illegal_keywords = [
                "dÃ©caisser le cpf", "rÃ©cupÃ©rer mon argent", "frauder",
                "arnaquer", "contourner", "bidouiller"
            ]
            
            if any(keyword in message_lower for keyword in illegal_keywords):
                logger.info("ðŸŽ¯ CONTEXTE LEGAL DÃ‰TECTÃ‰")
                return SimpleRAGDecision(
                    search_query="legal fraude cpf rÃ¨gles",
                    search_strategy="semantic",
                    context_needed=["legal", "recadrage"],
                    priority_level="high",
                    should_escalade=False,
                    system_instructions="""CONTEXTE DÃ‰TECTÃ‰: RECADRAGE LEGAL

Tu dois OBLIGATOIREMENT:
1. Appliquer le Bloc LEGAL immÃ©diatement
2. Reproduire EXACTEMENT le message de recadrage
3. Expliquer: pas d'inscription si but = rÃ©munÃ©ration
4. Orienter vers programme affiliation aprÃ¨s formation sÃ©rieuse
5. Maintenir un ton ferme mais pÃ©dagogique"""
                )
            
            # === DÃ‰TECTION AGRESSIVITÃ‰ ===
            aggressive_keywords = [
                "merde", "putain", "con", "salaud", "nul", "arnaque",
                "escroquerie", "voleur", "marre", "insulte"
            ]
            
            if any(keyword in message_lower for keyword in aggressive_keywords):
                logger.info("ðŸŽ¯ CONTEXTE AGRO DÃ‰TECTÃ‰")
                return SimpleRAGDecision(
                    search_query="gestion agressivitÃ© calme",
                    search_strategy="semantic",
                    context_needed=["agro", "apaisement"],
                    priority_level="high",
                    should_escalade=False,
                    system_instructions="""CONTEXTE DÃ‰TECTÃ‰: GESTION AGRO

Tu dois OBLIGATOIREMENT:
1. Appliquer le Bloc AGRO immÃ©diatement
2. Reproduire EXACTEMENT avec le poÃ¨me/chanson d'amour
3. Maintenir un ton humoristique mais ferme
4. Ne pas alimenter le conflit
5. Rediriger vers une conversation constructive"""
                )
            
            # === CONTEXTE GÃ‰NÃ‰RAL ===
            logger.info("ðŸŽ¯ CONTEXTE GÃ‰NÃ‰RAL")
            return SimpleRAGDecision(
                search_query=message,
                search_strategy="semantic",
                context_needed=["general"],
                priority_level="low",
                should_escalate=False,
                system_instructions="""CONTEXTE GÃ‰NÃ‰RAL

Tu dois:
1. Faire une recherche large dans Supabase Vector Store 2
2. Analyser les rÃ©sultats pour identifier le bon bloc
3. Identifier le profil utilisateur (ambassadeur, apprenant, prospect)
4. Si aucun bloc pertinent â†’ Appliquer les rÃ¨gles:
   - ProblÃ¨me paiement â†’ FILTRAGE PAIEMENT obligatoire
   - Demande spÃ©cifique â†’ Bloc appropriÃ©
   - Aucune correspondance â†’ Escalade avec Bloc G
5. Maintenir TOUJOURS le ton WhatsApp chaleureux avec emojis
6. Reproduire les blocs EXACTEMENT sans modification

RÃˆGLES ABSOLUES:
- Jamais d'improvisation
- Un seul bloc par rÃ©ponse
- Respect total du contenu avec emojis
- Filtrage paiement prioritaire
- Identification profil avant rÃ©ponse"""
            )
            
        except Exception as e:
            logger.error(f"Erreur dans analyze_intent: {str(e)}")
            # Retour de secours
            return SimpleRAGDecision(
                search_query=message,
                search_strategy="semantic",
                context_needed=["general"],
                priority_level="low",
                should_escalate=True,
                system_instructions="Erreur systÃ¨me - cherche dans Supabase et reproduis les blocs trouvÃ©s exactement. Si problÃ¨me paiement dÃ©tectÃ©, applique le filtrage obligatoire."
            )

class MemoryManager:
    """Gestionnaire de mÃ©moire ultra-simplifiÃ©"""
    
    @staticmethod
    def add_message(session_id: str, message: str, role: str = "user"):
        """Ajoute un message Ã  la mÃ©moire"""
        try:
            if session_id not in memory_store:
                memory_store[session_id] = []
            
            memory_store[session_id].append({
                "role": role,
                "content": message,
                "timestamp": "now"
            })
            
            # Limiter Ã  10 messages max
            if len(memory_store[session_id]) > 10:
                memory_store[session_id] = memory_store[session_id][-10:]
                
        except Exception as e:
            logger.error(f"Erreur mÃ©moire: {str(e)}")
    
    @staticmethod
    def get_context(session_id: str) -> List[Dict]:
        """RÃ©cupÃ¨re le contexte de conversation"""
        try:
            return memory_store.get(session_id, [])
        except Exception as e:
            logger.error(f"Erreur rÃ©cupÃ©ration contexte: {str(e)}")
            return []

# ENDPOINTS API

@app.get("/")
async def root():
    """Endpoint racine pour vÃ©rifier que l'API fonctionne"""
    return {
        "status": "healthy",
        "message": "JAK Company RAG API is running",
        "version": "2.1 Optimized with new blocks"
    }

@app.get("/health")
async def health_check():
    """Endpoint de santÃ© dÃ©taillÃ©"""
    return {
        "status": "healthy",
        "version": "2.1 Optimized",
        "active_sessions": len(memory_store),
        "features": [
            "Enhanced RAG Decision Engine",
            "New Ambassadeur/Affiliation Definition Blocks",
            "Context-Aware Search",
            "Robust Error Handling",
            "Memory Management", 
            "Ultra-Stable Processing",
            "Payment Filtering Priority",
            "Legal/Agro Detection"
        ]
    }

@app.post("/optimize_rag")
async def optimize_rag_decision(request: Request):
    """Point d'entrÃ©e principal - VERSION ULTRA ROBUSTE avec nouveaux blocs"""
    
    session_id = "default_session"
    user_message = "message par dÃ©faut"
    
    try:
        # === PARSING SÃ‰CURISÃ‰ ===
        try:
            body = await request.json()
            logger.info(f"Body reÃ§u: {body}")
        except Exception as e:
            logger.error(f"Erreur parsing JSON: {str(e)}")
            return {
                "optimized_response": "Erreur de format JSON",
                "search_query": "error",
                "search_strategy": "fallback",
                "context_needed": ["error"],
                "priority_level": "high",
                "system_instructions": "Erreur de parsing",
                "escalade_required": True,
                "response_type": "json_error",
                "session_id": "error_session",
                "rag_confidence": 0
            }

        # === EXTRACTION SÃ‰CURISÃ‰E DES DONNÃ‰ES ===
        try:
            user_message = str(body.get("message", "")).strip()
            session_id = str(body.get("session_id", "default_session"))
            
            if not user_message:
                user_message = "message vide"
                
            logger.info(f"[{session_id}] Message: '{user_message[:50]}...'")
            
        except Exception as e:
            logger.error(f"Erreur extraction donnÃ©es: {str(e)}")
            user_message = "erreur extraction"
            session_id = "error_session"

        # === GESTION MÃ‰MOIRE SÃ‰CURISÃ‰E ===
        try:
            MemoryManager.add_message(session_id, user_message, "user")
            conversation_context = MemoryManager.get_context(session_id)
        except Exception as e:
            logger.error(f"Erreur mÃ©moire: {str(e)}")
            conversation_context = []

        # === ANALYSE D'INTENTION SÃ‰CURISÃ‰E ===
        try:
            decision = SimpleRAGEngine.analyze_intent(user_message, session_id)
            logger.info(f"[{session_id}] DÃ‰CISION RAG: {decision.search_strategy} - {decision.priority_level}")
        except Exception as e:
            logger.error(f"Erreur analyse intention: {str(e)}")
            # DÃ©cision de fallback
            decision = SimpleRAGDecision(
                search_query=user_message,
                search_strategy="semantic",
                context_needed=["general"],
                priority_level="low",
                should_escalate=True,
                system_instructions="Erreur d'analyse - cherche dans Supabase et applique les rÃ¨gles JAK Company"
            )

        # === CONSTRUCTION RÃ‰PONSE SÃ‰CURISÃ‰E ===
        try:
            response_data = {
                "optimized_response": "RÃ©ponse optimisÃ©e gÃ©nÃ©rÃ©e avec nouveaux blocs",
                "search_query": decision.search_query,
                "search_strategy": decision.search_strategy,
                "context_needed": decision.context_needed,
                "priority_level": decision.priority_level,
                "system_instructions": decision.system_instructions,
                "escalade_required": decision.should_escalate,
                "response_type": "rag_optimized_robust_v2.1",
                "session_id": session_id,
                "rag_confidence": 9,  # Confiance trÃ¨s Ã©levÃ©e avec nouveaux blocs
                "conversation_length": len(conversation_context),
                "new_blocks_supported": ["AMBASSADEUR_DEFINITION", "AFFILIATION_DEFINITION"]
            }
            
            # Ajouter la rÃ©ponse Ã  la mÃ©moire
            MemoryManager.add_message(session_id, "RAG decision made with enhanced logic", "assistant")
            
            logger.info(f"[{session_id}] RAG Response gÃ©nÃ©rÃ© avec succÃ¨s: {decision.search_strategy}")
            
            return response_data
            
        except Exception as e:
            logger.error(f"Erreur construction rÃ©ponse: {str(e)}")
            return {
                "optimized_response": "Erreur construction rÃ©ponse",
                "search_query": user_message,
                "search_strategy": "fallback",
                "context_needed": ["error"],
                "priority_level": "high",
                "system_instructions": "Erreur systÃ¨me - escalade requise",
                "escalade_required": True,
                "response_type": "construction_error",
                "session_id": session_id,
                "rag_confidence": 0
            }

    except Exception as e:
        # === GESTION D'ERREUR GLOBALE ===
        logger.error(f"ERREUR GLOBALE: {str(e)}")
        logger.error(f"Stack trace: {traceback.format_exc()}")
        
        # RÃ©ponse de fallback ultra-robuste
        return {
            "optimized_response": "Erreur systÃ¨me dÃ©tectÃ©e",
            "search_query": user_message,
            "search_strategy": "fallback",
            "context_needed": ["error"],
            "priority_level": "high", 
            "system_instructions": "Erreur critique - escalade immÃ©diate requise",
            "escalade_required": True,
            "response_type": "global_error_fallback",
            "session_id": session_id,
            "rag_confidence": 0,
            "error_details": str(e)[:100]  # Limiter la taille de l'erreur
        }

@app.post("/clear_memory/{session_id}")
async def clear_memory(session_id: str):
    """Efface la mÃ©moire d'une session"""
    try:
        if session_id in memory_store:
            del memory_store[session_id]
            return {"status": "success", "message": f"Memory cleared for {session_id}"}
        return {"status": "info", "message": f"No memory found for {session_id}"}
    except Exception as e:
        logger.error(f"Erreur clear memory: {str(e)}")
        return {"status": "error", "message": "Erreur lors de l'effacement mÃ©moire"}

@app.get("/memory_status")
async def memory_status():
    """Statut de la mÃ©moire"""
    try:
        return {
            "active_sessions": len(memory_store),
            "sessions": list(memory_store.keys()),
            "total_messages": sum(len(messages) for messages in memory_store.values())
        }
    except Exception as e:
        logger.error(f"Erreur memory status: {str(e)}")
        return {"error": "Erreur rÃ©cupÃ©ration statut mÃ©moire"}

if __name__ == "__main__":
    import uvicorn
    try:
        logger.info("ðŸš€ DÃ©marrage JAK Company RAG API Robust v2.1 avec nouveaux blocs")
        uvicorn.run(app, host="0.0.0.0", port=int(os.getenv("PORT", 8000)))
    except Exception as e:
        logger.error(f"Erreur dÃ©marrage serveur: {str(e)}")
        print(f"ERREUR CRITIQUE: {str(e)}")