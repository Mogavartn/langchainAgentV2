#!/usr/bin/env python3
"""
Test complet pour v√©rifier la logique de paiement dans le contexte de l'Agent IA
"""

import asyncio
import sys
import os

# Ajouter le r√©pertoire courant au path pour importer process.py
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Simulation des classes n√©cessaires pour le test
from dataclasses import dataclass
from typing import List, Dict
from functools import lru_cache

@dataclass
class SimpleRAGDecision:
    """Structure simplifi√©e pour les d√©cisions RAG"""
    search_query: str
    search_strategy: str
    context_needed: List[str]
    priority_level: str
    should_escalate: bool
    system_instructions: str

class KeywordSets:
    def __init__(self):
        self.escalade_admin_keywords = frozenset([
            # Paiements et d√©lais anormaux
            "d√©lai anormal", "retard anormal", "paiement en retard", "virement en retard",
            "argent pas arriv√©", "virement pas re√ßu",
            "paiement bloqu√©", "virement bloqu√©", "argent bloqu√©",
            "en retard", "retard", "bloqu√©", "bloqu√©e",
            # Preuves et dossiers
            "justificatif", "preuve", "attestation", "certificat", "facture",
            "dossier bloqu√©", "dossier en attente", "dossier suspendu",
            "consultation fichier", "acc√®s fichier", "voir mon dossier",
            "√©tat dossier", "suivi dossier", "dossier administratif",
            "dossier", "fichier", "acc√®s", "consultation",
            # Probl√®mes techniques
            "erreur syst√®me", "bug", "probl√®me technique", "dysfonctionnement",
            "impossible de", "ne fonctionne pas", "√ßa marche pas",
            "probl√®me", "erreur", "dysfonctionnement"
        ])

class TestPaymentLogic:
    def __init__(self):
        self.keyword_sets = KeywordSets()
    
    @lru_cache(maxsize=50)
    def _detect_payment_request(self, message_lower: str) -> bool:
        """D√©tecte sp√©cifiquement les demandes de paiement avec plus de pr√©cision"""
        payment_request_patterns = frozenset([
            # Demandes directes de paiement
            "j'ai pas encore re√ßu mes sous", "j'ai pas encore re√ßu mes sous",
            "j'ai pas encore √©t√© pay√©", "j'ai pas encore √©t√© pay√©e",
            "j'attends toujours ma tune", "j'attends toujours mon argent",
            "j'attends toujours mon paiement", "j'attends toujours mon virement",
            "c'est quand que je serais pay√©", "c'est quand que je serai pay√©",
            "c'est quand que je vais √™tre pay√©", "c'est quand que je vais √™tre pay√©e",
            "quand est-ce que je serai pay√©", "quand est-ce que je serai pay√©e",
            "quand est-ce que je vais √™tre pay√©", "quand est-ce que je vais √™tre pay√©e",
            "quand je serais pay√©", "quand je serai pay√©",
            "quand je vais √™tre pay√©", "quand je vais √™tre pay√©e",
            # Demandes avec "pas encore"
            "pas encore re√ßu", "pas encore pay√©", "pas encore pay√©e",
            "pas encore eu", "pas encore touch√©", "pas encore touch√©e",
            "n'ai pas encore re√ßu", "n'ai pas encore pay√©", "n'ai pas encore pay√©e",
            "n'ai pas encore eu", "n'ai pas encore touch√©", "n'ai pas encore touch√©e",
            "je n'ai pas encore re√ßu", "je n'ai pas encore pay√©", "je n'ai pas encore pay√©e",
            "je n'ai pas encore eu", "je n'ai pas encore touch√©", "je n'ai pas encore touch√©e",
            # Demandes avec "toujours"
            "j'attends toujours", "j'attends encore",
            "j'attends toujours mon argent", "j'attends toujours mon paiement",
            "j'attends toujours mon virement", "j'attends encore mon argent",
            "j'attends encore mon paiement", "j'attends encore mon virement",
            # Demandes avec "toujours pas" (NOUVEAU - CORRECTION DU BUG)
            "toujours pas re√ßu", "toujours pas pay√©", "toujours pas pay√©e",
            "toujours pas eu", "toujours pas touch√©", "toujours pas touch√©e",
            "j'ai toujours pas re√ßu", "j'ai toujours pas pay√©", "j'ai toujours pas pay√©e",
            "j'ai toujours pas eu", "j'ai toujours pas touch√©", "j'ai toujours pas touch√©e",
            "je n'ai toujours pas re√ßu", "je n'ai toujours pas pay√©", "je n'ai toujours pas pay√©e",
            "je n'ai toujours pas eu", "je n'ai toujours pas touch√©", "je n'ai toujours pas touch√©e",
            # Demandes avec "toujours pas √©t√©" (NOUVEAU - CORRECTION DU BUG)
            "toujours pas √©t√© pay√©", "toujours pas √©t√© pay√©e",
            "j'ai toujours pas √©t√© pay√©", "j'ai toujours pas √©t√© pay√©e",
            "je n'ai toujours pas √©t√© pay√©", "je n'ai toujours pas √©t√© pay√©e",
            # Demandes avec "pas"
            "pas re√ßu", "pas pay√©", "pas pay√©e", "pas eu", "pas touch√©", "pas touch√©e",
            "n'ai pas re√ßu", "n'ai pas pay√©", "n'ai pas pay√©e", "n'ai pas eu",
            "n'ai pas touch√©", "n'ai pas touch√©e", "je n'ai pas re√ßu",
            "je n'ai pas pay√©", "je n'ai pas pay√©e", "je n'ai pas eu",
            "je n'ai pas touch√©", "je n'ai pas touch√©e",
            # Demandes avec "re√ßois quand" (NOUVEAU - CORRECTION DU BUG)
            "re√ßois quand", "re√ßois quand mes", "re√ßois quand mon",
            "je re√ßois quand", "je re√ßois quand mes", "je re√ßois quand mon",
            # Termes g√©n√©riques de paiement
            "sous", "tune", "argent", "paiement", "virement", "r√©mun√©ration"
        ])
        return any(term in message_lower for term in payment_request_patterns)
    
    @lru_cache(maxsize=100)
    def _has_keywords(self, message_lower: str, keyword_set: frozenset) -> bool:
        """Optimized keyword matching with caching"""
        return any(keyword in message_lower for keyword in keyword_set)
    
    @lru_cache(maxsize=50)
    def _extract_time_info(self, message_lower: str) -> dict:
        """Extrait les informations de temps et de financement du message"""
        import re
        
        # D√©tection des d√©lais
        time_patterns = {
            'days': r'(\d+)\s*(jour|jours|j)',
            'months': r'(\d+)\s*(mois|moi)',
            'weeks': r'(\d+)\s*(semaine|semaines|sem)'
        }
        
        time_info = {}
        for time_type, pattern in time_patterns.items():
            match = re.search(pattern, message_lower)
            if match:
                time_info[time_type] = int(match.group(1))
        
        # D√©tection du type de financement
        financing_type = "unknown"
        if "cpf" in message_lower:
            financing_type = "cpf"
        elif "opco" in message_lower:
            financing_type = "opco"
        elif any(term in message_lower for term in ["direct", "pay√©", "financ√©", "moi-m√™me"]):
            financing_type = "direct"
        
        return {
            'time_info': time_info,
            'financing_type': financing_type
        }
    
    def _create_payment_filtering_decision(self, message: str) -> SimpleRAGDecision:
        """Cr√©e une d√©cision pour le BLOC F (demande d'informations)"""
        return SimpleRAGDecision(
            search_query="demande informations paiement",
            search_strategy="payment_filtering",
            context_needed=["financing_type", "formation_end_date"],
            priority_level="high",
            should_escalate=False,
            system_instructions="""Tu es un assistant sp√©cialis√© dans les questions de paiement de formation.

L'utilisateur demande des informations sur son paiement mais tu n'as pas assez d'informations pour l'aider efficacement.

Pour que je puisse t'aider au mieux, est-ce que tu peux me pr√©ciser :

‚óè Comment la formation a-t-elle √©t√© financ√©e ? (CPF, OPCO, paiement direct)
‚óè Et environ quand elle s'est termin√©e ?

Une fois que j'aurai ces informations, je pourrai te donner une r√©ponse pr√©cise sur les d√©lais de paiement."""
        )
    
    def _create_escalade_admin_decision(self) -> SimpleRAGDecision:
        """Cr√©e une d√©cision pour l'escalade admin (BLOC 6.1)"""
        return SimpleRAGDecision(
            search_query="escalade admin paiement",
            search_strategy="escalade_admin",
            context_needed=["payment_issue"],
            priority_level="critical",
            should_escalate=True,
            system_instructions="""üîÅ ESCALADE AGENT ADMIN
üïê Notre √©quipe traite les demandes du lundi au vendredi, de 9h √† 17h (hors pause d√©jeuner).
On te tiendra inform√© d√®s qu'on a du nouveau ‚úÖ"""
        )
    
    async def analyze_intent(self, message: str, session_id: str = "default") -> SimpleRAGDecision:
        """Analyse l'intention de mani√®re robuste et optimis√©e"""
        
        try:
            message_lower = message.lower().strip()
            
            # NOUVELLES D√âTECTIONS POUR BLOCS 6.1 ET 6.2 (PRIORIT√â HAUTE)
            # Escalade Admin (BLOC 6.1) - Priorit√© haute
            if self._has_keywords(message_lower, self.keyword_sets.escalade_admin_keywords):
                return self._create_escalade_admin_decision()
            
            # Payment detection (high priority) - RENFORC√âE
            elif self._detect_payment_request(message_lower):
                # Extraire les informations de temps et financement
                time_financing_info = self._extract_time_info(message_lower)
                
                # V√©rifier si on a d√©j√† les informations n√©cessaires
                has_financing_info = time_financing_info['financing_type'] != 'unknown'
                has_time_info = bool(time_financing_info['time_info'])
                
                # Si on n'a pas les informations n√©cessaires, appliquer le BLOC F
                if not has_financing_info or not has_time_info:
                    return self._create_payment_filtering_decision(message)
                # Sinon, appliquer la logique sp√©cifique selon le type de financement et d√©lai
                elif time_financing_info['financing_type'] == 'direct' and time_financing_info['time_info'].get('days', 0) > 7:
                    return self._create_escalade_admin_decision()
                elif time_financing_info['financing_type'] == 'opco' and time_financing_info['time_info'].get('months', 0) > 2:
                    return self._create_escalade_admin_decision()
                elif time_financing_info['financing_type'] == 'cpf' and time_financing_info['time_info'].get('days', 0) > 45:
                    return self._create_escalade_admin_decision()
                else:
                    return self._create_payment_filtering_decision(message)
            
            # Fallback
            else:
                return SimpleRAGDecision(
                    search_query="general",
                    search_strategy="general",
                    context_needed=[],
                    priority_level="normal",
                    should_escalate=False,
                    system_instructions="R√©ponse g√©n√©rale"
                )
        
        except Exception as e:
            return SimpleRAGDecision(
                search_query="error",
                search_strategy="fallback",
                context_needed=[],
                priority_level="normal",
                should_escalate=False,
                system_instructions="Erreur de traitement"
            )

async def test_complete_payment_logic():
    """Test la logique compl√®te de paiement"""
    
    print("üß™ TEST COMPLET DE LA LOGIQUE DE PAIEMENT")
    print("=" * 70)
    
    # Initialiser le moteur de test
    payment_logic = TestPaymentLogic()
    
    # Messages de test qui posaient probl√®me
    test_messages = [
        "j'ai toujours pas re√ßu mon argent",
        "j'ai toujours pas re√ßu mes sous", 
        "j'ai toujours pas √©t√© pay√©",
        "je re√ßois quand mes sous ?"
    ]
    
    print("\nüìã MESSAGES DE TEST :")
    for i, message in enumerate(test_messages, 1):
        print(f"{i}. '{message}'")
    
    print("\nüîç R√âSULTATS DE L'ANALYSE COMPL√àTE :")
    print("-" * 50)
    
    all_correct = True
    
    for i, message in enumerate(test_messages, 1):
        print(f"\n{i}. Message: '{message}'")
        
        # Analyser l'intention compl√®te
        decision = await payment_logic.analyze_intent(message, f"test_session_{i}")
        
        print(f"   ‚Üí Strat√©gie: {decision.search_strategy}")
        print(f"   ‚Üí Priorit√©: {decision.priority_level}")
        print(f"   ‚Üí Escalade: {'‚úÖ OUI' if decision.should_escalate else '‚ùå NON'}")
        print(f"   ‚Üí Instructions: {decision.system_instructions[:100]}...")
        
        # V√©rifier que c'est bien le BLOC F qui est appliqu√©
        if decision.search_strategy == "payment_filtering":
            print(f"   ‚úÖ CORRECT: BLOC F appliqu√© (demande d'informations)")
        elif decision.search_strategy == "escalade_admin":
            print(f"   ‚ùå PROBL√àME: Escalade admin appliqu√©e au lieu du BLOC F")
            all_correct = False
        else:
            print(f"   ‚ö†Ô∏è  ATTENTION: Autre strat√©gie appliqu√©e")
            all_correct = False
    
    print("\n" + "=" * 70)
    print("üéØ R√âSULTAT ATTENDU :")
    print("Tous les messages doivent d√©clencher le BLOC F (payment_filtering)")
    print("et demander des informations au lieu de l'escalade admin.")
    print("=" * 70)
    
    if all_correct:
        print("\nüéâ SUCC√àS: Tous les tests passent ! Le bug est corrig√©.")
        print("‚úÖ La logique de paiement fonctionne maintenant correctement.")
    else:
        print("\n‚ùå √âCHEC: Certains tests √©chouent. Le bug persiste.")
    
    return all_correct

if __name__ == "__main__":
    asyncio.run(test_complete_payment_logic())