#!/usr/bin/env python3
"""
Test simplifi√© des corrections apport√©es au syst√®me de d√©tection LangChain
"""

import re
from typing import Dict, Any, Optional, List, Set
from dataclasses import dataclass
from functools import lru_cache

# Simuler les classes n√©cessaires pour le test
class KeywordSets:
    def __init__(self):
        self.payment_keywords = frozenset([
            "pas √©t√© pay√©", "pas pay√©", "paiement", "cpf", "opco", 
            "virement", "argent", "retard", "d√©lai", "attends",
            "finance", "financement", "pay√© pour", "rien re√ßu",
            "je vais √™tre pay√© quand", "d√©lai paiement",
            "pay√© tout seul", "financ√© tout seul", "financ√© en direct",
            "paiement direct", "financement direct", "j'ai pay√©", 
            "j'ai financ√©", "pay√© par moi", "financ√© par moi",
            "sans organisme", "financement personnel", "paiement personnel",
            "auto-financ√©", "autofinanc√©", "mes fonds", "mes propres fonds",
            "direct", "tout seul", "par moi-m√™me", "par mes soins"
        ])

class SimpleRAGDecision:
    """Structure simplifi√©e pour les d√©cisions RAG"""
    def __init__(self, search_query: str, search_strategy: str, context_needed: List[str], 
                 priority_level: str, should_escalate: bool, system_instructions: str):
        self.search_query = search_query
        self.search_strategy = search_strategy
        self.context_needed = context_needed
        self.priority_level = priority_level
        self.should_escalate = should_escalate
        self.system_instructions = system_instructions

class TestRAGEngine:
    """Moteur de test pour valider les corrections"""
    
    def __init__(self):
        self.keyword_sets = KeywordSets()
    
    @lru_cache(maxsize=50)
    def _detect_direct_financing(self, message_lower: str) -> bool:
        """D√©tecte sp√©cifiquement les termes de financement direct/personnel"""
        direct_financing_terms = frozenset([
            "pay√© tout seul", "financ√© tout seul", "financ√© en direct",
            "paiement direct", "financement direct", "j'ai pay√©", 
            "j'ai financ√©", "pay√© par moi", "financ√© par moi",
            "sans organisme", "financement personnel", "paiement personnel",
            "auto-financ√©", "autofinanc√©", "mes fonds", "par mes soins",
            "j'ai pay√© toute seule", "j'ai pay√© moi", "c'est moi qui est financ√©",
            "financement moi m√™me", "financement en direct", "paiement direct",
            "j'ai financ√© toute seule", "j'ai financ√© moi", "c'est moi qui ai pay√©",
            "financement par mes soins", "paiement par mes soins", "mes propres moyens",
            "avec mes propres fonds", "de ma poche", "de mes √©conomies",
            "financement individuel", "paiement individuel", "auto-financement",
            "financement priv√©", "paiement priv√©", "financement personnel",
            "j'ai tout pay√©", "j'ai tout financ√©", "c'est moi qui finance",
            "financement direct", "paiement en direct", "financement cash",
            "paiement cash", "financement comptant", "paiement comptant"
        ])
        return any(term in message_lower for term in direct_financing_terms)
    
    @lru_cache(maxsize=50)
    def _detect_opco_financing(self, message_lower: str) -> bool:
        """D√©tecte sp√©cifiquement les termes de financement OPCO"""
        opco_financing_terms = frozenset([
            "opco", "op√©rateur de comp√©tences", "op√©rateur comp√©tences",
            "financement opco", "paiement opco", "financ√© par opco",
            "pay√© par opco", "opco finance", "opco paie",
            "organisme paritaire", "paritaire", "fonds formation",
            "financement paritaire", "paiement paritaire"
        ])
        return any(term in message_lower for term in opco_financing_terms)
    
    @lru_cache(maxsize=50)
    def _extract_time_info(self, message_lower: str) -> dict:
        """Extrait les informations de temps et de financement du message"""
        # D√©tection des d√©lais
        time_patterns = {
            'days': r'(\d+)\s*(jour|jours|j)',
            'months': r'(\d+)\s*(mois|moi)',
            'weeks': r'(\d+)\s*(semaine|semaines|sem)'
        }
        
        time_info = {}
        for time_type, pattern in time_patterns.items():
            match = re.search(pattern, message_lower)
            if match:
                time_info[time_type] = int(match.group(1))
        
        # D√©tection du type de financement
        financing_type = "unknown"
        if self._detect_direct_financing(message_lower):
            financing_type = "direct"
        elif self._detect_opco_financing(message_lower):
            financing_type = "opco"
        elif "cpf" in message_lower:
            financing_type = "cpf"
        
        return {
            'time_info': time_info,
            'financing_type': financing_type
        }
    
    def analyze_payment_decision(self, message: str) -> str:
        """Analyse la d√©cision de paiement selon les nouvelles r√®gles"""
        message_lower = message.lower()
        
        # V√©rifier si c'est un message de paiement
        if not any(keyword in message_lower for keyword in self.keyword_sets.payment_keywords):
            return "not_payment"
        
        # Extraire les informations de temps et financement
        time_financing_info = self._extract_time_info(message_lower)
        
        # Appliquer la logique sp√©cifique selon le type de financement et d√©lai
        if time_financing_info['financing_type'] == 'direct' and time_financing_info['time_info'].get('days', 0) > 7:
            return "payment_direct_delayed"  # BLOC L
        elif time_financing_info['financing_type'] == 'opco' and time_financing_info['time_info'].get('months', 0) > 2:
            return "escalade_admin"  # BLOC 6.1
        elif time_financing_info['financing_type'] == 'cpf' and time_financing_info['time_info'].get('days', 0) > 45:
            return "escalade_admin"  # BLOC 6.1
        else:
            return "payment_normal"  # D√©cision paiement normale

def test_corrections():
    """Test des corrections apport√©es"""
    
    print("üß™ TEST DES CORRECTIONS LANGCHAIN")
    print("=" * 50)
    
    # Initialiser le moteur de test
    rag_engine = TestRAGEngine()
    
    # Tests de d√©tection de financement
    print("\n1Ô∏è‚É£ TEST D√âTECTION FINANCEMENT")
    print("-" * 30)
    
    test_cases = [
        # Test OPCO
        {
            "message": "OPCO il y a 20 jours",
            "expected_financing": "opco",
            "expected_days": 20,
            "expected_months": 0,
            "description": "OPCO 20 jours (d√©lai normal)"
        },
        {
            "message": "OPCO il y a 3 mois",
            "expected_financing": "opco", 
            "expected_days": 0,
            "expected_months": 3,
            "description": "OPCO 3 mois (d√©lai d√©pass√©)"
        },
        # Test Paiement Direct
        {
            "message": "j'ai pay√© tout seul il y a 5 jours",
            "expected_financing": "direct",
            "expected_days": 5,
            "expected_months": 0,
            "description": "Paiement direct 5 jours (d√©lai normal)"
        },
        {
            "message": "paiement direct il y a 10 jours",
            "expected_financing": "direct",
            "expected_days": 10,
            "expected_months": 0,
            "description": "Paiement direct 10 jours (d√©lai d√©pass√©)"
        },
        # Test CPF
        {
            "message": "CPF il y a 30 jours",
            "expected_financing": "cpf",
            "expected_days": 30,
            "expected_months": 0,
            "description": "CPF 30 jours (d√©lai normal)"
        },
        {
            "message": "CPF il y a 60 jours",
            "expected_financing": "cpf",
            "expected_days": 60,
            "expected_months": 0,
            "description": "CPF 60 jours (d√©lai d√©pass√©)"
        }
    ]
    
    for i, test_case in enumerate(test_cases, 1):
        print(f"\nTest {i}: {test_case['description']}")
        print(f"Message: '{test_case['message']}'")
        
        # Extraire les informations
        time_info = rag_engine._extract_time_info(test_case['message'].lower())
        
        print(f"Financing d√©tect√©: {time_info['financing_type']}")
        print(f"Jours d√©tect√©s: {time_info['time_info'].get('days', 0)}")
        print(f"Mois d√©tect√©s: {time_info['time_info'].get('months', 0)}")
        
        # V√©rifier les r√©sultats
        financing_ok = time_info['financing_type'] == test_case['expected_financing']
        days_ok = time_info['time_info'].get('days', 0) == test_case['expected_days']
        months_ok = time_info['time_info'].get('months', 0) == test_case['expected_months']
        
        if financing_ok and days_ok and months_ok:
            print("‚úÖ R√âSULTAT: CORRECT")
        else:
            print("‚ùå R√âSULTAT: INCORRECT")
            if not financing_ok:
                print(f"   - Financement attendu: {test_case['expected_financing']}, d√©tect√©: {time_info['financing_type']}")
            if not days_ok:
                print(f"   - Jours attendus: {test_case['expected_days']}, d√©tect√©s: {time_info['time_info'].get('days', 0)}")
            if not months_ok:
                print(f"   - Mois attendus: {test_case['expected_months']}, d√©tect√©s: {time_info['time_info'].get('months', 0)}")
    
    # Tests de logique de d√©cision
    print("\n\n2Ô∏è‚É£ TEST LOGIQUE DE D√âCISION")
    print("-" * 30)
    
    decision_tests = [
        {
            "message": "OPCO il y a 20 jours",
            "expected_decision": "payment_normal",
            "description": "OPCO 20 jours ‚Üí D√©cision paiement normale"
        },
        {
            "message": "OPCO il y a 3 mois", 
            "expected_decision": "escalade_admin",
            "description": "OPCO 3 mois ‚Üí Escalade admin"
        },
        {
            "message": "j'ai pay√© tout seul il y a 5 jours",
            "expected_decision": "payment_normal", 
            "description": "Direct 5 jours ‚Üí D√©cision paiement normale"
        },
        {
            "message": "paiement direct il y a 10 jours",
            "expected_decision": "payment_direct_delayed",
            "description": "Direct 10 jours ‚Üí BLOC L (d√©lai d√©pass√©)"
        },
        {
            "message": "CPF il y a 30 jours",
            "expected_decision": "payment_normal",
            "description": "CPF 30 jours ‚Üí D√©cision paiement normale"
        },
        {
            "message": "CPF il y a 60 jours",
            "expected_decision": "escalade_admin",
            "description": "CPF 60 jours ‚Üí Escalade admin"
        }
    ]
    
    for i, test_case in enumerate(decision_tests, 1):
        print(f"\nTest {i}: {test_case['description']}")
        print(f"Message: '{test_case['message']}'")
        
        # Analyser la d√©cision
        decision = rag_engine.analyze_payment_decision(test_case['message'])
        
        print(f"D√©cision d√©tect√©e: {decision}")
        
        if decision == test_case['expected_decision']:
            print("‚úÖ R√âSULTAT: CORRECT")
        else:
            print("‚ùå R√âSULTAT: INCORRECT")
            print(f"   - D√©cision attendue: {test_case['expected_decision']}")
            print(f"   - D√©cision d√©tect√©e: {decision}")
    
    print("\n\nüéØ R√âSUM√â DES CORRECTIONS")
    print("=" * 50)
    print("‚úÖ D√©tection OPCO vs Paiement Direct am√©lior√©e")
    print("‚úÖ BLOC L pour paiement direct d√©lai d√©pass√© (au lieu de BLOC J)")
    print("‚úÖ Logique de d√©lais corrig√©e:")
    print("   - Direct: ‚â§7j normal, >7j BLOC L")
    print("   - OPCO: ‚â§2 mois normal, >2 mois escalade admin")
    print("   - CPF: ‚â§45j normal, >45j escalade admin")
    print("‚úÖ D√©tection automatique des types de financement")
    print("‚úÖ Extraction intelligente des d√©lais")

if __name__ == "__main__":
    test_corrections()