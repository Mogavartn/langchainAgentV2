#!/usr/bin/env python3
"""
Script d'analyse pour examiner et optimiser la base de donn√©es Supabase
Usage: python3 supabase_analyzer.py
"""

import os
import asyncio
import json
from typing import Dict, List, Any, Optional
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class SupabaseAnalyzer:
    """Analyseur pour examiner la structure et les donn√©es Supabase"""
    
    def __init__(self):
        self.client = None
        self.analysis_results = {}
        
    async def initialize_connection(self) -> bool:
        """Initialise la connexion √† Supabase"""
        try:
            from supabase import create_client, Client
            
            supabase_url = os.getenv("SUPABASE_URL")
            supabase_key = os.getenv("SUPABASE_KEY")
            
            if not supabase_url or not supabase_key:
                print("‚ùå Variables d'environnement SUPABASE_URL et SUPABASE_KEY requises")
                print("üìù Ajoutez-les dans votre fichier .env")
                return False
            
            self.client = create_client(supabase_url, supabase_key)
            print("‚úÖ Connexion Supabase √©tablie")
            return True
            
        except ImportError:
            print("‚ùå Client Supabase non install√©")
            print("üìù Installez avec: pip install supabase")
            return False
        except Exception as e:
            print(f"‚ùå Erreur de connexion: {e}")
            return False
    
    async def analyze_database_structure(self) -> Dict[str, Any]:
        """Analyse la structure de la base de donn√©es"""
        print("\nüîç ANALYSE DE LA STRUCTURE DE BASE DE DONN√âES")
        print("=" * 60)
        
        structure_analysis = {
            "tables": [],
            "total_tables": 0,
            "recommendations": []
        }
        
        try:
            # Obtenir la liste des tables (requ√™te PostgreSQL)
            result = self.client.rpc('get_table_info').execute()
            
            if result.data:
                structure_analysis["tables"] = result.data
                structure_analysis["total_tables"] = len(result.data)
                print(f"üìä Nombre de tables trouv√©es: {len(result.data)}")
                
                for table in result.data:
                    print(f"  üìã Table: {table.get('table_name', 'Unknown')}")
                    
            else:
                print("‚ÑπÔ∏è  Utilisation d'une m√©thode alternative pour l'analyse...")
                # Fallback: essayer d'analyser des tables communes
                common_tables = ['content_blocks', 'users', 'conversations', 'messages', 'blocks']
                
                for table_name in common_tables:
                    try:
                        result = self.client.table(table_name).select("*").limit(1).execute()
                        if result.data is not None:
                            structure_analysis["tables"].append({
                                "table_name": table_name,
                                "accessible": True
                            })
                            print(f"  ‚úÖ Table accessible: {table_name}")
                    except:
                        print(f"  ‚ùå Table non accessible: {table_name}")
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur analyse structure: {e}")
            structure_analysis["error"] = str(e)
        
        self.analysis_results["structure"] = structure_analysis
        return structure_analysis
    
    async def analyze_content_blocks(self) -> Dict[str, Any]:
        """Analyse sp√©cifique de la table content_blocks (suppos√©e)"""
        print("\nüìã ANALYSE DE LA TABLE CONTENT_BLOCKS")
        print("=" * 60)
        
        blocks_analysis = {
            "total_blocks": 0,
            "categories": {},
            "contexts": {},
            "sample_blocks": [],
            "recommendations": []
        }
        
        try:
            # Compter le total
            result = self.client.table("content_blocks").select("*", count="exact").execute()
            
            if result.data is not None:
                blocks_analysis["total_blocks"] = len(result.data)
                print(f"üìä Total des blocs: {len(result.data)}")
                
                # Analyser les cat√©gories
                categories = {}
                contexts = {}
                
                for block in result.data:
                    # Cat√©gories
                    category = block.get('category', 'UNKNOWN')
                    categories[category] = categories.get(category, 0) + 1
                    
                    # Contextes
                    context = block.get('context', 'UNKNOWN')
                    contexts[context] = contexts.get(context, 0) + 1
                
                blocks_analysis["categories"] = categories
                blocks_analysis["contexts"] = contexts
                
                # √âchantillon de blocs
                blocks_analysis["sample_blocks"] = result.data[:5]
                
                print(f"üìà Cat√©gories trouv√©es:")
                for category, count in categories.items():
                    print(f"  ‚Ä¢ {category}: {count} blocs")
                
                print(f"üè∑Ô∏è  Contextes trouv√©s:")
                for context, count in contexts.items():
                    print(f"  ‚Ä¢ {context}: {count} blocs")
                
                # Recommandations
                if len(categories) > 10:
                    blocks_analysis["recommendations"].append("Consid√©rer regrouper certaines cat√©gories")
                
                if 'UNKNOWN' in categories:
                    blocks_analysis["recommendations"].append("Certains blocs n'ont pas de cat√©gorie d√©finie")
            
            else:
                print("‚ùå Aucun bloc trouv√© ou table inaccessible")
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur analyse content_blocks: {e}")
            blocks_analysis["error"] = str(e)
        
        self.analysis_results["content_blocks"] = blocks_analysis
        return blocks_analysis
    
    async def analyze_performance_opportunities(self) -> Dict[str, Any]:
        """Analyse les opportunit√©s d'optimisation de performance"""
        print("\n‚ö° ANALYSE DES OPPORTUNIT√âS DE PERFORMANCE")
        print("=" * 60)
        
        performance_analysis = {
            "indexing_recommendations": [],
            "query_optimizations": [],
            "data_structure_improvements": []
        }
        
        try:
            # Analyser la structure des donn√©es pour les index
            if "content_blocks" in self.analysis_results:
                blocks_data = self.analysis_results["content_blocks"]
                
                if blocks_data.get("total_blocks", 0) > 100:
                    performance_analysis["indexing_recommendations"].extend([
                        "Index sur 'category' recommand√© pour les requ√™tes par cat√©gorie",
                        "Index sur 'context' recommand√© pour les requ√™tes par contexte",
                        "Index de recherche textuelle sur 'content' pour la recherche s√©mantique"
                    ])
                
                # Recommandations bas√©es sur les cat√©gories
                categories = blocks_data.get("categories", {})
                if len(categories) > 5:
                    performance_analysis["query_optimizations"].append(
                        "Utiliser des requ√™tes avec filtres sp√©cifiques plut√¥t que des scans complets"
                    )
                
                # Recommandations de structure
                if blocks_data.get("total_blocks", 0) > 1000:
                    performance_analysis["data_structure_improvements"].extend([
                        "Consid√©rer la pagination pour les grandes requ√™tes",
                        "Impl√©menter un cache pour les blocs fr√©quemment utilis√©s",
                        "S√©parer les blocs actifs des blocs archiv√©s"
                    ])
            
            print("üéØ Recommandations d'indexation:")
            for rec in performance_analysis["indexing_recommendations"]:
                print(f"  ‚Ä¢ {rec}")
            
            print("üöÄ Optimisations de requ√™tes:")
            for rec in performance_analysis["query_optimizations"]:
                print(f"  ‚Ä¢ {rec}")
            
            print("üèóÔ∏è  Am√©liorations de structure:")
            for rec in performance_analysis["data_structure_improvements"]:
                print(f"  ‚Ä¢ {rec}")
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur analyse performance: {e}")
            performance_analysis["error"] = str(e)
        
        self.analysis_results["performance"] = performance_analysis
        return performance_analysis
    
    async def analyze_code_integration_opportunities(self) -> Dict[str, Any]:
        """Analyse les opportunit√©s d'int√©gration avec le code existant"""
        print("\nüîß ANALYSE D'INT√âGRATION AVEC LE CODE")
        print("=" * 60)
        
        integration_analysis = {
            "langchain_optimizations": [],
            "n8n_workflow_improvements": [],
            "caching_strategies": []
        }
        
        try:
            # Analyser les donn√©es pour l'int√©gration
            if "content_blocks" in self.analysis_results:
                blocks_data = self.analysis_results["content_blocks"]
                categories = blocks_data.get("categories", {})
                
                # Recommandations LangChain
                if "PAIEMENT" in categories:
                    integration_analysis["langchain_optimizations"].append(
                        "Cr√©er des cha√Ænes sp√©cialis√©es pour les requ√™tes de paiement"
                    )
                
                if "AMBASSADEUR" in categories:
                    integration_analysis["langchain_optimizations"].append(
                        "Impl√©menter un syst√®me de templates pour les r√©ponses ambassadeur"
                    )
                
                # Recommandations N8N
                integration_analysis["n8n_workflow_improvements"].extend([
                    "Cr√©er des webhooks sp√©cialis√©s par cat√©gorie de bloc",
                    "Impl√©menter un syst√®me de fallback pour les blocs non trouv√©s",
                    "Ajouter des logs structur√©s pour le debugging"
                ])
                
                # Strat√©gies de cache
                total_blocks = blocks_data.get("total_blocks", 0)
                if total_blocks > 50:
                    integration_analysis["caching_strategies"].extend([
                        "Cache Redis pour les blocs fr√©quemment utilis√©s",
                        "Cache local avec TTL pour les r√©ponses",
                        "Invalidation de cache bas√©e sur les mises √† jour"
                    ])
            
            print("ü§ñ Optimisations LangChain:")
            for rec in integration_analysis["langchain_optimizations"]:
                print(f"  ‚Ä¢ {rec}")
            
            print("üîÑ Am√©liorations N8N:")
            for rec in integration_analysis["n8n_workflow_improvements"]:
                print(f"  ‚Ä¢ {rec}")
            
            print("üíæ Strat√©gies de cache:")
            for rec in integration_analysis["caching_strategies"]:
                print(f"  ‚Ä¢ {rec}")
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur analyse int√©gration: {e}")
            integration_analysis["error"] = str(e)
        
        self.analysis_results["integration"] = integration_analysis
        return integration_analysis
    
    async def generate_optimization_report(self) -> str:
        """G√©n√®re un rapport complet d'optimisation"""
        print("\nüìä G√âN√âRATION DU RAPPORT D'OPTIMISATION")
        print("=" * 60)
        
        report_path = "/workspace/supabase_optimization_report.json"
        
        try:
            with open(report_path, 'w', encoding='utf-8') as f:
                json.dump(self.analysis_results, f, indent=2, ensure_ascii=False)
            
            print(f"‚úÖ Rapport g√©n√©r√©: {report_path}")
            return report_path
        
        except Exception as e:
            print(f"‚ùå Erreur g√©n√©ration rapport: {e}")
            return ""
    
    async def run_complete_analysis(self):
        """Lance l'analyse compl√®te"""
        print("üöÄ D√âMARRAGE DE L'ANALYSE SUPABASE")
        print("=" * 60)
        
        if not await self.initialize_connection():
            return
        
        # Analyses s√©quentielles
        await self.analyze_database_structure()
        await self.analyze_content_blocks()
        await self.analyze_performance_opportunities()
        await self.analyze_code_integration_opportunities()
        
        # G√©n√©ration du rapport
        report_path = await self.generate_optimization_report()
        
        print("\nüéâ ANALYSE TERMIN√âE")
        print("=" * 60)
        print(f"üìÑ Rapport disponible: {report_path}")
        print("üîß Consultez le rapport pour les recommandations d√©taill√©es")

async def main():
    """Fonction principale"""
    analyzer = SupabaseAnalyzer()
    await analyzer.run_complete_analysis()

if __name__ == "__main__":
    asyncio.run(main())